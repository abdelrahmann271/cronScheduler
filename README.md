# Project: Cron Scheduler

1. [Project Setup](#project-setup)
2. [Solution](#solution)
3. [Decisions?](#hDecisions)
4. [Trade-offs](#trade-offs)
5. [Example usage snippet(s).](#example-usage-snippet(s).)
6. [Possible future improvements.](#possible-future-improvements)

## Project Setup
* Create a new project in your preferred IDE (e.g., IntelliJ IDEA (Preferably)).
* Choose "Maven" as the build system during project creation (if applicable) or configure it later in the IDE settings.
* Import Existing Project:
  * Navigate to the project import option in your IDE.
  * Select the directory containing the pom.xml file.
  * The IDE will typically import the project and configure it based on the `pom.xml` settings.
    
## Solution
This solution implements a modular job scheduling framework designed for flexibility and control over scheduled tasks.
Here's a breakdown of the key components:
 * `Job` (implements `Executable`): This represents the individual unit of work to be executed. It encapsulates:
   * Job `Name`: A human-readable name for identification.
   * Job `ID`: A unique identifier for the job (generated by `java.util.UUID`).
   * `Runnable` Function: The actual code to be executed by the scheduler. This function is provided by the client when creating a Job.

 * `ScheduledJob` (implements `Schedulable`): This ties a Job to a specific execution schedule. It contains:
   * `Job`: The Job object that defines the work to be done.
   * `ID` : A unique identifier for the scheduled job within the scheduler (generated by `java.util.UUID`).
   * `Trigger`: The Trigger object that defines when and how often the Job should be executed.

 * `Trigger` (implements `SchedulingTrigger`): This defines the timing logic for a ScheduledJob. It specifies:
   * Start Delay: The initial delay before the first execution of the Job.
   * Time Period: The interval at which the Job should be executed repeatedly. This can be a one-time execution or a recurring schedule.
  
 * `Scheduler` (implements `SchedulingService`): This is the central component that manages job execution. It utilizes a:
   * `PriorityBlockingQueue`: This internal queue prioritizes ScheduledJobs based on their designated firing times.
   * The scheduler constantly checks the queue based on a timer and executes the Job at the queue's head when its firing time arrives.
 
## Decisions
* `Scheduler` uses `newCachedThreadPool`.
  * A `CachedThreadPool` maintains a pool of threads ready to handle incoming tasks.
    This eliminates the overhead of creating new threads for each task, which can be expensive.
    When a new task arrives, an idle thread from the pool is assigned, leading to faster task execution.
  * By reusing threads, `CachedThreadPool` avoids the overhead of creating and destroying threads for short-lived tasks.
    This helps manage system resources (CPU, memory) more efficiently.
* In order to execute a job for a one time. Client should create the `Trigger` with `scheduleFrequency` equals to `null` or `new TimePeriod(0,0,0,0,0,0)`
* All jobs execution details and submission in the executor service are logged in `cron.log` and errors are logged separately in `error.log` in the `logs` directory.
* The smallest scheduling frequency is `1 second`.
* Every `Job` can be scheduled for execution with any created `Trigger` by creating a new `ScheduledJob` tbat contains the `Job` and the `Trigger`.
* `Job`s should be added first to the `Scheduler` before starting their executions.
* The `Scheduler` should be started first, before starting any `ScheduledJob`.
  
## Trade-offs
The scheduler is implemented in a non-blocking approach with a timer. Instead of constantly checking the queue and executes the Job at the queue's head when its firing time arrives.
As the problem with a busy wait on the queue is inefficiency.
The scheduler uses a priority queue to store jobs based on firing time.
Instead of busy waiting, A timer is implemented (Using `Timer` class in Java) that fires at regular intervals `1 sec`.
When the timer fires, check the top element of the queue.
If the firing time of the top element is less than the current time, execute the job and remove it from the queue.

## Example usage snippet(s).

![image](https://github.com/abdelrahmann271/cronScheduler/assets/42815782/204dd561-0f8c-4700-9487-6828b11f38c2)

Logs snippet from `cron.log` file:
![image](https://github.com/abdelrahmann271/cronScheduler/assets/42815782/2bcf840e-5253-4cef-a15e-7cbbbdbfbf69)

More test cases are for the scheduler are provided in the `src/test/java/cron/scheduler/SchedulerTest.java`

## Possible future improvements

* Persistent Job Storage
  * Consider implementing persistent storage for both ``Jobs and `ScheduledJobs` using a database.
  This ensures job definitions and schedules are not lost in case of application restarts or server failures.
  This improves reliability and makes it easier to resume scheduled tasks after interruptions.

* Cron Expression Support:
  * Enhance the framework by incorporating a Cron expression parser. This would allow clients to define job schedules using Cron expressions.
 
* Infinite Thread Creation
  * `CachedThreadPool` can grow the thread pool indefinitely.
    It's crucial to monitor the pool size and implement mechanisms to prevent resource exhaustion, especially under high loads.
